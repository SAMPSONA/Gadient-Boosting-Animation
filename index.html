<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Gradient Boosting Animation (Self-Contained)</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    :root{
      --bg:#0f172a; --panel:#111827; --text:#e5e7eb; --muted:#9ca3af;
      --accent:#22d3ee; --ok:#34d399; --warn:#fbbf24;
      --radius:14px; --shadow:0 10px 25px rgba(2,6,23,.25);
    }
    *{box-sizing:border-box}
    body{
      margin:2rem; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      color:var(--text); background:var(--bg);
    }
    h1{margin:.2rem 0 1rem; font-size:1.4rem; color:var(--text)}
    .card{
      background:var(--panel); border-radius:var(--radius);
      box-shadow:var(--shadow); padding:1rem; max-width:1000px;
    }
    #plot{width:100%; height:480px;}
    .row{display:flex; gap:1rem; flex-wrap:wrap; align-items:center; margin-top:1rem}
    .control{
      background:#0b1220; padding:.75rem 1rem; border-radius:12px; border:1px solid #1f2937;
    }
    label{color:var(--muted); font-size:.9rem; margin-right:.5rem}
    #tree-slider{width:320px}
    select, input[type="range"]{
      accent-color:var(--accent);
    }
    .badge{
      display:inline-block; padding:.2rem .5rem; border-radius:999px; background:#0b2030; color:#9ce2ff; border:1px solid #123;
      font-size:.8rem; margin-left:.5rem;
    }
    .legend{
      display:flex; gap:1rem; align-items:center; margin-top:.5rem; color:var(--muted); font-size:.9rem;
    }
    .dot{display:inline-block; width:10px; height:10px; border-radius:50%}
    .dot.data{background:#eab308}
    .dot.model{background:#60a5fa}
    .dot.res{background:#ef4444}
    button{
      background:#0b2740; border:1px solid #123e63; color:#cdeaff; padding:.55rem .8rem; border-radius:10px; cursor:pointer;
    }
    button:hover{filter:brightness(1.1)}
  </style>
</head>
<body>
  <div class="card">
    <h1>Gradient Boosting Animation</h1>
    <div id="plot"></div>

    <div class="row">
      <div class="control">
        <label>Tree number:
          <span id="tree-num-label" class="badge">1</span>
        </label>
        <input id="tree-slider" type="range" min="1" max="100" value="1" step="1">
      </div>

      <div class="control">
        <label for="lr-select">Learning rate</label>
        <select id="lr-select">
          <option value="0.01">0.01</option>
          <option value="0.05">0.05</option>
          <option value="0.1" selected>0.1</option>
          <option value="0.2">0.2</option>
          <option value="0.3">0.3</option>
        </select>
        <span class="badge" id="trees-used">trained: 100 trees</span>
      </div>

      <div class="control">
        <button id="reshuffle">Resample data</button>
      </div>
    </div>

    <div class="legend">
      <span><span class="dot data"></span> data (y)</span>
      <span><span class="dot model"></span> model prediction</span>
      <span><span class="dot res"></span> residual (vertical)</span>
    </div>
  </div>

<script>
/**
 * Simple Gradient Boosting Regressor with decision stumps (1D).
 * - Fits to synthetic data y = sin(x) + noise on x in [-3.2, 3.2].
 * - Each weak learner is a stump: predict left/right mean of residuals at best split.
 * - We retrain when learning rate changes or data is resampled.
 * - Slider shows partial ensemble up to k trees.
 */

(function(){
  // --- Config ---
  const N_POINTS = 120;
  const MAX_TREES = 100;
  const X_MIN = -3.2, X_MAX = 3.2;
  const GRID_N = 400;

  // --- DOM ---
  const slider = document.getElementById('tree-slider');
  const treeLabel = document.getElementById('tree-num-label');
  const lrSelect = document.getElementById('lr-select');
  const treesUsedEl = document.getElementById('trees-used');
  const reshuffleBtn = document.getElementById('reshuffle');

  // --- Data holders ---
  let dataX = [], dataY = [];
  let gridX = [];
  let ensemble = [];   // list of {thr, left, right}
  let lr = parseFloat(lrSelect.value);

  // Utility
  const linspace = (a,b,n) => Array.from({length:n}, (_,i)=> a + (b-a)*i/(n-1));
  const mean = arr => arr.length ? arr.reduce((s,v)=>s+v,0)/arr.length : 0;

  function genData(seed=Math.random()){
    // simple LCG for reproducible noise if needed
    let s = Math.floor(seed * 1e6) % 2147483647;
    function rnd(){ s = (s * 48271) % 2147483647; return s/2147483647; }

    dataX = linspace(X_MIN, X_MAX, N_POINTS).map(x => x + (rnd()-0.5)*0.05);
    dataY = dataX.map(x => Math.sin(1.2*x) + 0.3*Math.cos(2.0*x) + (rnd()-0.5)*0.25);
    gridX = linspace(X_MIN, X_MAX, GRID_N);
  }

  // Decision stump trained on residuals
  function fitStump(x, r){
    // candidates: midpoints between sorted unique x
    const idx = x.map((v,i)=>[v,i]).sort((a,b)=>a[0]-b[0]).map(p=>p[1]);
    const xs = idx.map(i=>x[i]);
    const rs = idx.map(i=>r[i]);

    // prefix sums to compute means quickly
    const prefix = [0];
    for(let i=0;i<rs.length;i++) prefix.push(prefix[prefix.length-1] + rs[i]);

    let best = {mse: Infinity, thr: xs[0], left: 0, right: 0};

    for(let i=1;i<xs.length;i++){
      if(xs[i]===xs[i-1]) continue;
      const thr = 0.5*(xs[i]+xs[i-1]);
      const nL = i, nR = rs.length - i;
      const sumL = prefix[i], sumR = prefix[rs.length] - prefix[i];
      const muL = nL ? sumL / nL : 0;
      const muR = nR ? sumR / nR : 0;
      // MSE on residuals if we predict piecewise means
      const mseL = nL ? rs.slice(0,i).reduce((s,v)=>s+(v-muL)**2,0) : 0;
      const mseR = nR ? rs.slice(i).reduce((s,v)=>s+(v-muR)**2,0) : 0;
      const mse = (mseL + mseR) / rs.length;
      if(mse < best.mse){
        best = {mse, thr, left: muL, right: muR};
      }
    }
    return best;
  }

  function predictWithStump(stump, x){
    return (x <= stump.thr) ? stump.left : stump.right;
  }

  function trainBoosting(x, y, nTrees, learningRate){
    let F = new Array(x.length).fill(0);
    const learners = [];
    for(let t=0; t<nTrees; t++){
      const residuals = y.map((yi,i)=> yi - F[i]);
      const stump = fitStump(x, residuals);
      learners.push(stump);
      // update F
      for(let i=0;i<x.length;i++){
        F[i] += learningRate * predictWithStump(stump, x[i]);
      }
    }
    return learners;
  }

  function predictEnsemble(learners, learningRate, xs, uptoK=null){
    const K = uptoK==null ? learners.length : Math.min(uptoK, learners.length);
    const out = new Array(xs.length).fill(0);
    for(let t=0;t<K;t++){
      const stump = learners[t];
      for(let i=0;i<xs.length;i++){
        out[i] += learningRate * predictWithStump(stump, xs[i]);
      }
    }
    return out;
  }

  function currentK(){ return parseInt(slider.value, 10); }

  // Plot
  function initPlot(){
    const yModel = predictEnsemble(ensemble, lr, gridX, 1);
    const residualLines = residualSegments(dataX, dataY, predictEnsemble(ensemble, lr, dataX, 1));

    const traces = [
      // data points
      {
        x: dataX, y: dataY, mode: 'markers', name: 'data',
        marker: { size: 6, color: '#eab308', opacity: 0.9 }
      },
      // model line
      {
        x: gridX, y: yModel, mode: 'lines', name: 'model',
        line: { width: 3, color: '#60a5fa' }
      },
      // residuals as vertical segments
      {
        x: residualLines.x, y: residualLines.y, mode: 'lines',
        name: 'residuals', line: { width: 1, color: '#ef4444' },
        hoverinfo: 'skip', showlegend: true
      }
    ];
    Plotly.newPlot('plot', traces, {
      margin: {l:40, r:20, t:10, b:40},
      paper_bgcolor: 'rgba(0,0,0,0)',
      plot_bgcolor: 'rgba(0,0,0,0)',
      xaxis: {gridcolor:'#1f2937', zeroline:false},
      yaxis: {gridcolor:'#1f2937', zeroline:false}
    }, {displayModeBar:false, responsive:true});
  }

  function residualSegments(x, y, yhat){
    // create vertical line segments as one trace with NaN separators
    const X = [], Y = [];
    for(let i=0;i<x.length;i++){
      X.push(x[i]); Y.push(y[i]);
      X.push(x[i]); Y.push(yhat[i]);
      X.push(NaN);  Y.push(NaN);
    }
    return {x:X, y:Y};
  }

  function refreshPlotAtK(k){
    treeLabel.textContent = String(k);
    const lineY = predictEnsemble(ensemble, lr, gridX, k);
    const yhatTrain = predictEnsemble(ensemble, lr, dataX, k);
    const segs = residualSegments(dataX, dataY, yhatTrain);

    Plotly.animate('plot', {
      data: [
        null, // keep points
        {y: lineY}, // model line
        {x: segs.x, y: segs.y} // residuals
      ]
    }, {
      transition: {duration: 80, easing: 'linear'},
      frame: {duration: 0, redraw: true}
    });
  }

  function retrainAndReset(){
    lr = parseFloat(lrSelect.value);
    ensemble = trainBoosting(dataX, dataY, MAX_TREES, lr);
    treesUsedEl.textContent = `trained: ${MAX_TREES} trees`;
    slider.max = String(MAX_TREES);
    slider.value = "1";
    treeLabel.textContent = "1";
    initPlot();
  }

  // --- Events ---
  slider.addEventListener('input', () => refreshPlotAtK(currentK()));
  lrSelect.addEventListener('change', retrainAndReset);
  reshuffleBtn.addEventListener('click', () => {
    genData(Math.random());
    retrainAndReset();
  });

  // --- Boot ---
  genData(0.42);
  ensemble = trainBoosting(dataX, dataY, MAX_TREES, lr);
  initPlot();

})();
</script>
</body>
</html>
